class AFND:
    def __init__(self, alfabeto, estados, transicoes, estado_inicial, estados_finais):
        self.alfabeto = alfabeto
        self.estados = estados
        self.transicoes = transicoes  
        self.estado_inicial = estado_inicial
        self.estados_finais = estados_finais

    def eh_deterministico(self):
        for estado in self.estados:
            for simbolo in self.alfabeto:
                destinos = self.transicoes.get((estado, simbolo), [])
                if len(destinos) > 1:
                    return False
                if simbolo == 'e' and destinos:
                    return False
        return True

    def fecho_epsilon(self, estados):
        fecho = set(estados)
        pilha = list(estados)
        while pilha:
            estado = pilha.pop()
            destinos = self.transicoes.get((estado, 'e'), [])
            for destino in destinos:
                if destino not in fecho:
                    fecho.add(destino)
                    pilha.append(destino)
        return fecho

    def converter_para_afd(self):
        print("\nIniciando conversão de AFND para AFD...")
        novo_inicial = frozenset(self.fecho_epsilon([self.estado_inicial]))
        estados_afd = [novo_inicial]
        transicoes_afd = {}
        estados_finais_afd = []
        if any(estado in self.estados_finais for estado in novo_inicial):
            estados_finais_afd.append(novo_inicial)
        fila = [novo_inicial]
        processados = set()
        while fila:
            conjunto_atual = fila.pop(0)
            if conjunto_atual in processados:
                continue
            processados.add(conjunto_atual)
            for simbolo in self.alfabeto:
                if simbolo == 'e':
                    continue
                destinos = set()
                for estado in conjunto_atual:
                    destinos.update(self.transicoes.get((estado, simbolo), []))
                if not destinos:
                    continue
                novo_conjunto = frozenset(self.fecho_epsilon(destinos))
                transicoes_afd[(conjunto_atual, simbolo)] = novo_conjunto
                if novo_conjunto not in estados_afd:
                    estados_afd.append(novo_conjunto)
                    fila.append(novo_conjunto)
                if any(estado in self.estados_finais for estado in novo_conjunto):
                    if novo_conjunto not in estados_finais_afd:
                        estados_finais_afd.append(novo_conjunto)
        mapeamento = {conjunto: f'q{i}' for i, conjunto in enumerate(estados_afd)}
        novas_transicoes = {}
        for (conjunto, simbolo), destino in transicoes_afd.items():
            novas_transicoes[(mapeamento[conjunto], simbolo)] = mapeamento[destino]
        novos_estados = [mapeamento[conjunto] for conjunto in estados_afd]
        novo_estado_inicial = mapeamento[novo_inicial]
        novos_estados_finais = [mapeamento[conjunto] for conjunto in estados_finais_afd]
        print("\nConversão concluída com sucesso!")
        print(f"Estados do AFD: {novos_estados}")
        print(f"Estado inicial: {novo_estado_inicial}")
        print(f"Estados finais: {novos_estados_finais}")
        print("Transições:")
        for (origem, simbolo), destino in novas_transicoes.items():
            print(f"  {origem} --{simbolo}--> {destino}")
        return AFD(self.alfabeto, novos_estados, novas_transicoes, novo_estado_inicial, novos_estados_finais)


class AFD:
    def __init__(self, alfabeto, estados, transicoes, estado_inicial, estados_finais):
        self.alfabeto = alfabeto
        self.estados = estados
        self.transicoes = transicoes
        self.estado_inicial = estado_inicial
        self.estados_finais = estados_finais

    def eh_deterministico(self):
        for estado in self.estados:
            for simbolo in self.alfabeto:
                if list(self.transicoes.keys()).count((estado, simbolo)) > 1:
                    return False
        return True

    def eh_total(self):
        for estado in self.estados:
            for simbolo in self.alfabeto:
                if (estado, simbolo) not in self.transicoes:
                    return False
        return True

    def adicionar_estado_artificial(self):
        estado_artificial = 'A'
        if estado_artificial not in self.estados:
            self.estados.append(estado_artificial)
        for estado in self.estados:
            for simbolo in self.alfabeto:
                if (estado, simbolo) not in self.transicoes:
                    self.transicoes[(estado, simbolo)] = estado_artificial
        print(f"Estado artificial '{estado_artificial}' adicionado para completar a função de transição.")

    def estados_alcancaveis(self):
        alcancaveis = set()
        self._dfs(self.estado_inicial, alcancaveis)
        return alcancaveis == set(self.estados)

    def _dfs(self, estado, alcancaveis):
        alcancaveis.add(estado)
        for simbolo in self.alfabeto:
            proximo_estado = self.transicoes.get((estado, simbolo))
            if proximo_estado and proximo_estado not in alcancaveis:
                self._dfs(proximo_estado, alcancaveis)

    def minimizar(self):
        print("\nIniciando processo de minimização...")
        if not self.eh_deterministico():
            return "O autômato não é determinístico. Minimização não pode ser realizada."
        if not self.eh_total():
            print("Função de transição não é total. Adicionando estado artificial...")
            self.adicionar_estado_artificial()
        if not self.estados_alcancaveis():
            return "Nem todos os estados são alcançáveis. Minimização não pode ser realizada."

        n = len(self.estados)
        tabela = [[False] * n for _ in range(n)]
        index_map = {self.estados[i]: i for i in range(n)}

        print("\nPasso 1: Marcando pares de estados trivialmente não equivalentes...")
        for i in range(n):
            for j in range(i):
                estado1, estado2 = self.estados[i], self.estados[j]
                if (estado1 in self.estados_finais) != (estado2 in self.estados_finais):
                    tabela[i][j] = True
                    print(f"Marcados como não equivalentes: ({estado1}, {estado2})")

        print("\nPasso 2: Analisando pares restantes...")
        mudou = True
        while mudou:
            mudou = False
            for i in range(n):
                for j in range(i):
                    if tabela[i][j]:
                        continue
                    for simbolo in self.alfabeto:
                        proximo1 = self.transicoes.get((self.estados[i], simbolo))
                        proximo2 = self.transicoes.get((self.estados[j], simbolo))
                        if proximo1 and proximo2:
                            if tabela[index_map[proximo1]][index_map[proximo2]]:
                                tabela[i][j] = True
                                mudou = True
                                print(f"Marcados como não equivalentes: ({self.estados[i]}, {self.estados[j]}) com símbolo '{simbolo}'")
                                break

        print("\nPasso 3: Unificando estados equivalentes...")
        novos_estados = set(self.estados)
        unificacao = {}
        for i in range(n):
            for j in range(i):
                if not tabela[i][j]:
                    unificacao[self.estados[i]] = self.estados[j]
                    novos_estados.discard(self.estados[i])
                    print(f"Unificando: {self.estados[i]} -> {self.estados[j]}")

        print("\nPasso 4: Gerando nova função de transição...")
        novas_transicoes = {}
        for (estado, simbolo), proximo_estado in self.transicoes.items():
            novo_estado = unificacao.get(estado, estado)
            novo_proximo_estado = unificacao.get(proximo_estado, proximo_estado)
            novas_transicoes[(novo_estado, simbolo)] = novo_proximo_estado

        self.estados = list(novos_estados)
        self.transicoes = novas_transicoes
        self.estados_finais = [unificacao.get(estado, estado) for estado in self.estados_finais if estado in novos_estados]

        print("\nAFD minimizado com sucesso!")
        return tabela

    def validar_palavra(self, palavra_entrada):
        estado_atual = self.estado_inicial
        print(f"\nValidando a palavra '{palavra_entrada}':")
        for simbolo in palavra_entrada:
            if simbolo not in self.alfabeto:
                print(f"Erro: Símbolo '{simbolo}' não pertence ao alfabeto.")
                return False
            proximo_estado = self.transicoes.get((estado_atual, simbolo))
            if not proximo_estado:
                print(f"Erro: Não há transição do estado '{estado_atual}' com '{simbolo}'.")
                return False
            print(f"Transição: {estado_atual} --({simbolo})--> {proximo_estado}")
            estado_atual = proximo_estado
        if estado_atual in self.estados_finais:
            print(f"A palavra foi aceita. Estado final: {estado_atual}")
            return True
        else:
            print(f"A palavra foi rejeitada. Estado final: {estado_atual} (não é estado final)")
            return False


def imprimir_tabela(tabela, estados):
    print("\nTabela de Pares de Estados Possíveis:")
    n = len(estados)
    print("   " + "  ".join(estados))
    for i in range(n):
        linha = f"{estados[i]} "
        for j in range(i):
            linha += " T " if tabela[i][j] else " F "
        print(linha)


def criar_afnd():
    alfabeto = input("Digite o alfabeto (símbolos separados por espaço, use 'e' para epsilon): ").split()
    estados = input("Digite os estados (separados por espaço): ").split()
    estado_inicial = input("Digite o estado inicial: ")
    estados_finais = input("Digite os estados finais (separados por espaço): ").split()
    transicoes = {}
    print("Defina as transições (no formato 'estado atual símbolo estados seguintes'):")
    print("Exemplo: q0 a q1 q2 (para transições não determinísticas)")
    print("Para epsilon transições, use e como símbolo")
    while True:
        entrada = input("Transição (ou 'done' para finalizar): ")
        if entrada == "done":
            break
        partes = entrada.split()
        estado_atual = partes[0]
        simbolo = partes[1]
        estados_destino = partes[2:]
        transicoes[(estado_atual, simbolo)] = estados_destino
    return AFND(alfabeto, estados, transicoes, estado_inicial, estados_finais)


def criar_afd():
    alfabeto = input("Digite o alfabeto (símbolos separados por espaço): ").split()
    estados = input("Digite os estados (separados por espaço): ").split()
    estado_inicial = input("Digite o estado inicial: ")
    estados_finais = input("Digite os estados finais (separados por espaço): ").split()
    transicoes = {}
    print("Defina as transições (no formato 'estado atual símbolo estado seguinte'):")
    while True:
        entrada = input("Transição (ou 'done' para finalizar): ")
        if entrada == "done":
            break
        estado_atual, simbolo, proximo_estado = entrada.split()
        transicoes[(estado_atual, simbolo)] = proximo_estado
    return AFD(alfabeto, estados, transicoes, estado_inicial, estados_finais)



class Gramatica:
    def __init__(self, nao_terminais, terminais, producoes, inicial):
        self.N = set(nao_terminais)
        self.T = set(terminais)
        self.producoes = producoes  
        self.S = inicial

    def __str__(self):
        s = f"N = {self.N}\nT = {self.T}\nP = {{\n"
        for A in self.producoes:
            for prod in self.producoes[A]:
                s += f"  {A} -> {' '.join(prod) if prod != ['ε'] else 'ε'}\n"
        s += f"}}\nS = {self.S}"
        return s

    def classificar(self):
        """
        Retorna 'regular' se a gramática for regular (linear à direita) ou 'livre contexto' caso contrário.
        Considera regras da forma A -> a B ou A -> a (ou A -> ε) como regulares.
        """
        for A in self.producoes:
            for prod in self.producoes[A]:
                if prod == ['ε']:
                    continue  
                if len(prod) > 2:
                    return "livre contexto"
                if len(prod) == 2:
                    if prod[0] not in self.T or prod[1] not in self.N:
                        return "livre contexto"
                elif len(prod) == 1:
                    if prod[0] not in self.T:
                        return "livre contexto"
        return "regular"

    def converter_para_afd(self):
        """
        Converte uma gramática regular (linear à direita) para AFD.
        Retorna um objeto AFD.
        """
        estados = list(self.N) + ['F']
        estado_inicial = self.S
        estados_finais = []
        transicoes = {}

        for A in self.producoes:
            for prod in self.producoes[A]:
                if prod == ['ε']:
                    if A not in estados_finais:
                        estados_finais.append(A)
                elif len(prod) == 1:
                    a = prod[0]
                    transicoes[(A, a)] = 'F'
                    if 'F' not in estados_finais:
                        estados_finais.append('F')
                elif len(prod) == 2:
                    a = prod[0]
                    B = prod[1]
                    transicoes[(A, a)] = B

        alfabeto = list(self.T)
        return AFD(alfabeto, estados, transicoes, estado_inicial, estados_finais)

    def simplificar(self):
        print("\nIniciando simplificação da gramática...")
        self.eliminar_epsilon()
        self.eliminar_unitarias()
        self.eliminar_inuteis()
        print("Simplificação concluída.")

    def eliminar_epsilon(self):
        print("\nPasso 1: Eliminando produções vazias (ε)...")
        
        anulaveis = set()
        mudou = True
        while mudou:
            mudou = False
            for A in self.N:
                if A in anulaveis:
                    continue
                for prod in self.producoes.get(A, []):
                    if prod == ['ε'] or all(sim in anulaveis for sim in prod):
                        anulaveis.add(A)
                        mudou = True
                        print(f"  {A} é anulável")
                        break

       
        novas_producoes = {A: [] for A in self.producoes}
        for A in self.producoes:
            for prod in self.producoes[A]:
                if prod == ['ε']:
                    continue
                
                pos_anulaveis = [i for i, sim in enumerate(prod) if sim in anulaveis]
                from itertools import combinations
                for r in range(len(pos_anulaveis) + 1):
                    for comb in combinations(pos_anulaveis, r):
                        nova_prod = [prod[i] for i in range(len(prod)) if i not in comb]
                        if nova_prod:
                            if nova_prod not in novas_producoes[A]:
                                novas_producoes[A].append(nova_prod)
                       
        self.producoes = novas_producoes

        
        if self.S in anulaveis:
            if self.S not in self.producoes:
                self.producoes[self.S] = []
            if ['ε'] not in self.producoes[self.S]:
                self.producoes[self.S].append(['ε'])
                print(f"  Adicionado S -> ε porque S é anulável.")

        print("Produções vazias eliminadas (exceto possível S -> ε).")

    def eliminar_unitarias(self):
        print("\nPasso 2: Eliminando produções unitárias (A -> B)...")
        
        fecho_unitario = {}
        for A in self.N:
            fecho = set()
            fila = [A]
            while fila:
                B = fila.pop()
                if B in fecho:
                    continue
                fecho.add(B)
                for prod in self.producoes.get(B, []):
                    if len(prod) == 1 and prod[0] in self.N:
                        fila.append(prod[0])
            fecho_unitario[A] = fecho

        
        novas_producoes = {A: [] for A in self.N}
        for A in self.N:
            for B in fecho_unitario[A]:
                for prod in self.producoes.get(B, []):
                    if len(prod) == 1 and prod[0] in self.N:
                        continue
                    if prod not in novas_producoes[A]:
                        novas_producoes[A].append(prod)
        self.producoes = novas_producoes
        print("Produções unitárias eliminadas.")

    def eliminar_inuteis(self):
        print("\nPasso 3: Eliminando símbolos inúteis...")
        
        geradores = set()
        mudou = True
        while mudou:
            mudou = False
            for A in self.N:
                if A in geradores:
                    continue
                for prod in self.producoes.get(A, []):
                    if prod == ['ε'] or all(sim in self.T or sim in geradores for sim in prod):
                        geradores.add(A)
                        mudou = True
                        print(f"  {A} é gerador")
                        break

        nao_geradores = self.N - geradores
        for A in nao_geradores:
            print(f"  Removendo não-terminal não gerador: {A}")
            del self.producoes[A]
        self.N = geradores

       
        alcancaveis = set()
        fila = [self.S]
        while fila:
            A = fila.pop()
            if A in alcancaveis:
                continue
            alcancaveis.add(A)
            for prod in self.producoes.get(A, []):
                for sim in prod:
                    if sim in self.N and sim not in alcancaveis:
                        fila.append(sim)

        nao_alcancaveis = self.N - alcancaveis
        for A in nao_alcancaveis:
            print(f"  Removendo não-terminal inalcançável: {A}")
            del self.producoes[A]
        self.N = alcancaveis

        print("Símbolos inúteis eliminados.")

    def derivar(self, palavra, max_profundidade=100):
        """
        Tenta derivar a palavra a partir da gramática usando backtracking.
        Retorna uma lista de passos (strings) ou None.
        """
        print(f"\nTentando derivar '{palavra}'...")
       
        alvo = list(palavra)  
        derivacao = []
        if self._derivar_rec([self.S], alvo, derivacao, max_profundidade):
            print("Derivação encontrada:")
            for i, passo in enumerate(derivacao):
                print(f"  {i}: {''.join(passo)}")
            return derivacao
        else:
            print("Não foi possível derivar a palavra.")
            return None

    def _derivar_rec(self, atual, alvo, derivacao, max_profundidade):
        if len(derivacao) > max_profundidade:
            return False
        if atual == alvo:
            return True
        if len(atual) > len(alvo):
            return False

    
        for i, sim in enumerate(atual):
            if sim in self.N:
                for prod in self.producoes.get(sim, []):
                    if prod == ['ε']:
                        nova = atual[:i] + atual[i+1:]
                    else:
                        nova = atual[:i] + prod + atual[i+1:]
                    derivacao.append(nova)
                    if self._derivar_rec(nova, alvo, derivacao, max_profundidade):
                        return True
                    derivacao.pop()
                return False
        return False

    def pseudocodigo(self):
        tipo = self.classificar()
        texto = f"\nPseudocódigo do reconhecedor para gramática {tipo}:\n"
        if tipo == "regular":
            afd = self.converter_para_afd()
            texto += "  O reconhecedor simula um AFD com os seguintes componentes:\n"
            texto += f"  Estados: {afd.estados}\n"
            texto += f"  Estado inicial: {afd.estado_inicial}\n"
            texto += f"  Estados finais: {afd.estados_finais}\n"
            texto += "  Função de transição:\n"
            for (e, s), d in afd.transicoes.items():
                texto += f"    {e} --{s}--> {d}\n"
            texto += "  Algoritmo:\n"
            texto += "    estado = estado_inicial\n"
            texto += "    para cada símbolo da palavra:\n"
            texto += "        se não há transição definida: rejeitar\n"
            texto += "        estado = transicao(estado, símbolo)\n"
            texto += "    se estado é final: aceitar; senão rejeitar\n"
        else:
            texto += "  O reconhecedor pode ser implementado como um parser descendente recursivo:\n"
            texto += "  Para cada não-terminal, crie uma função que tenta reconhecer a produção:\n"
            for A in self.N:
                texto += f"  function {A}():\n"
                texto += "    escolha uma produção:\n"
                for prod in self.producoes.get(A, []):
                    texto += f"      tentar: "
                    for sim in prod:
                        if sim in self.T:
                            texto += f"ler terminal '{sim}'; "
                        else:
                            texto += f"chamar {sim}(); "
                    texto += "\n"
                texto += "    se alguma tentativa bem-sucedida, retorna True; senão False\n"
            texto += "  Iniciar com S(). Se retornar True e toda a palavra foi consumida, aceitar.\n"
        return texto


def criar_gramatica():
    print("\nDefinição da Gramática:")
    nao_terminais = input("Digite os não-terminais (separados por espaço): ").split()
    terminais = input("Digite os terminais (separados por espaço): ").split()
    inicial = input("Digite o símbolo inicial: ")
    producoes = {}
    print("Defina as produções. Para cada produção, digite no formato: 'A -> simb1 simb2 ...'")
    print("Use 'ε' para representar vazio. Digite 'done' quando terminar.")
    while True:
        entrada = input("Produção: ")
        if entrada == "done":
            break
        if "->" not in entrada:
            print("Formato inválido. Use A -> simb1 simb2 ...")
            continue
        esquerda, direita = entrada.split("->")
        esquerda = esquerda.strip()
        direita = direita.strip()
        if direita == 'ε':
            prod = ['ε']
        else:
            prod = direita.split()
        if esquerda not in producoes:
            producoes[esquerda] = []
        producoes[esquerda].append(prod)
    return Gramatica(nao_terminais, terminais, producoes, inicial)


def main():
    while True:
        print("\n" + "="*50)
        print("PROJETO DE TEORIA DA COMPUTAÇÃO")
        print("="*50)
        print("Escolha uma opção:")
        print("1 - Trabalhar com Autômatos (AFD/AFND)")
        print("2 - Trabalhar com Gramáticas")
        print("0 - Sair")
        opcao = input("Opção: ")

        if opcao == "1":
            submenu_automatos()
        elif opcao == "2":
            submenu_gramaticas()
        elif opcao == "0":
            print("Encerrando...")
            break
        else:
            print("Opção inválida.")


def submenu_automatos():
    print("\n--- AUTÔMATOS ---")
    print("Escolha o tipo de autômato:")
    print("1 - Autômato Finito Determinístico (AFD)")
    print("2 - Autômato Finito Não Determinístico (AFND)")
    opcao = input("Opção: ")

    if opcao == "1":
        afd = criar_afd()
    elif opcao == "2":
        afnd = criar_afnd()
        print("\nAutômato Finito Não Determinístico criado:")
        print(f"Estados: {afnd.estados}")
        print(f"Estado inicial: {afnd.estado_inicial}")
        print(f"Estados finais: {afnd.estados_finais}")
        print("Transições:")
        for (origem, simbolo), destinos in afnd.transicoes.items():
            print(f"  {origem} --{simbolo}--> {', '.join(destinos)}")
        print("\nConvertendo AFND para AFD...")
        afd = afnd.converter_para_afd()
    else:
        print("Opção inválida.")
        return

    print("\n--- MINIMIZAÇÃO DO AFD ---")
    tabela = afd.minimizar()
    if isinstance(tabela, str):
        print(tabela)
    else:
        imprimir_tabela(tabela, afd.estados)

    while True:
        palavra = input("\nDigite uma palavra para testar (ou 'sair' para finalizar): ")
        if palavra == "sair":
            break
        afd.validar_palavra(palavra)


def submenu_gramaticas():
    print("\n--- GRAMÁTICAS ---")
    gram = criar_gramatica()
    print("\nGramática fornecida:")
    print(gram)

    tipo = gram.classificar()
    print(f"\nClassificação: {tipo}")

    if tipo == "regular":
        print("\nConvertendo gramática regular para AFD...")
        afd = gram.converter_para_afd()
        print("AFD gerado:")
        print(f"Estados: {afd.estados}")
        print(f"Estado inicial: {afd.estado_inicial}")
        print(f"Estados finais: {afd.estados_finais}")
        print("Transições:")
        for (origem, simbolo), destino in afd.transicoes.items():
            print(f"  {origem} --{simbolo}--> {destino}")
        while True:
            palavra = input("\nDigite uma palavra para testar no AFD (ou 'sair' para voltar): ")
            if palavra == "sair":
                break
            afd.validar_palavra(palavra)
    else:
        print("\nA gramática é livre de contexto. Iniciando simplificação...")
        gram.simplificar()
        print("\nGramática simplificada:")
        print(gram)

    palavra = input("\nDigite uma palavra para tentar derivar: ")
    gram.derivar(palavra)

    print(gram.pseudocodigo())


if __name__ == "__main__":
    main()
